// HW#3 Prob.2.(a)
// skeletonizing
// Submissioin Date: March.03
// USCID: 8372-7611-20
// Name: Wenjun Li

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <typeinfo>
#include <cstring>
#include <cmath>
#include <sstream>
#include <iostream>

using namespace std;

int HitOrMiss(string pixel_stream,string mask[], int size){
    int i;
    for(i=0;i<size;i++){
        if(pixel_stream.compare(mask[i]) == 0){
            return 1;
        }
    }
    return 0;
}

int output_logic(int X, int M, int P){
    /**
     * @ input: X, M, P
     * @ output: G
     * return the final result of S/T
     */
    int G = 0;
    if(( (X == 1) && (!M || P)) == 1)
    {
        G = 255;
    }
    return G;
}

int bridging(int x, int x0, int x1, int x2, int x3, int x4, int x5, int x6, int x7){
    int p1, p2, p3, p4, p5, p6, l1, l2, l3, l4, Pq;
    int G = 0;
    l1 = (!x) && (!x0) && (x1) && (!x2) && (x3) && (!x4) && (!x5) && (!x6) && (!x7);
    l2 = (!x) && (!x0) && (!x1) && (!x2) && (x3) && (!x4) && (x5) && (!x6) && (!x7);
    l3 = (!x) && (!x0) && (!x1) && (!x2) && (!x3) && (!x4) && (x5) && (!x6) && (x7);
    l4 = (!x) && (!x0) && (x1) && (!x2) && (!x3) && (!x4) && (!x5) && (!x6) && (x7);
    Pq = l1 || l2 || l3 || l4;

    p1 = (!x2) && (!x6) && (x3||x4||x5) && (x0||x1||x7) && (!Pq);
    p2 = (!x0) && (!x4) && (x1||x2||x3) && (x5||x6||x7) && (!Pq);
    p3 = (!x0) && (!x6) && (x7) && (x2||x3||x4);
    p4 = (!x0) && (!x2) && (x1) && (x4||x5||x6);
    p5 = (!x2) && (!x4) && (x3) && (x0||x6||x7);
    p6 = (!x4) && (!x6) && (x5) && (x0||x1||x2);

    G = x || ( p1||p2||p3||p4||p5||p6 );

    return G;
}

int main(int argc, char *argv[]) {

    FILE *file;
    int BytesPerPixel = 1;
    int size = 375;
    unsigned char Imagedata[size][size][BytesPerPixel];

    if (!(file=fopen("/Users/wenjun/ee569/hw3/pattern4.raw","rb"))) {
        cout << "Cannot open file: " <<endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), 375*375*1, file);
    fclose(file);

    //////////////////////////////////////////// ... STK ... /////////////////////////////////////////////////
    int i, j, iter;
    int Size = size + 2;
    int img_extd[Size][Size][BytesPerPixel]; unsigned char output[size][size][1];
    int bond_number;
    int bond_map[size][size];// store bond number
    int m[Size][Size];       // extended mark map
    int M[size][size];       // mark map
    int P[Size][Size];       // P map
    string pixel_stream[size][size];
    string mark_stream;

    string con_mask[40] = {"010011000", "010110000", "000110010", "000011010", "001011001", "111010000", "100110100", "000010111",
                           "111011000", "011011001", "111110000", "110110100", "100110110", "000110111", "000011111", "001011011",
                           "111011001", "111110100", "100110111", "001011111",
                           "011011011", "111111000", "110110110", "000111111",
                           "111011011", "011011111", "111111100", "111111001", "111110110", "110110111", "100111111", "001111111",
                           "111011111", "111111101", "111110111", "101111111", "111111011", "111111110", "110111111", "011111111"};

    string uncon_mask[444]={"000010001", "000010100", "001010000", "100010000", "000010010", "000011000", "000110000", "010010000",
                            "010011000", "010110000", "000011010", "000110010",

                            "110110000", "000011011", "110110001", "000011111", "110110010", "000111011", "110110011", "000111111",
                            "110110100", "001011011", "110110101", "001011111", "110110110", "001111011", "110110111", "001111111",
                            "110111000", "010011011", "110111001", "010011111", "110111010", "010111011", "110111011", "010111111",
                            "110111100", "011011011", "110111101", "011011111", "110111110", "011111011", "110111111", "011111111",
                            "111110000", "100011011", "111110001", "100011111", "111110010", "100111011", "111110011", "100111111",
                            "111110100", "101011011", "111110101", "101011111", "111110110", "101111011", "111110111", "101111111",
                            "111111000", "110011011", "111111001", "110011111", "111111010", "110111011", "111111011", "110111111",
                            "111111100", "111011011", "111111101", "111011111", "111111110", "111111011", "111111111", "111111111",
                            "010111000", "010110010", "000111010", "010011010", "010111001", "010110011", "000111011", "010011011",
                            "010111010", "010110110", "000111110", "010011110", "010111011", "010110111", "000111111", "010011111",
                            "010111100", "010111010", "001111010", "010111010", "010111101", "010111011", "001111011", "010111011",
                            "010111110", "010111110", "001111110", "010111110", "010111111", "010111111", "001111111", "010111111",
                            "011111000", "011110010", "010111010", "011011010", "011111001", "011110011", "010111011", "011011011",
                            "011111010", "011110110", "010111110", "011011110", "011111011", "011110111", "010111111", "011011111",
                            "011111100", "011111010", "011111010", "011111010", "011111101", "011111011", "011111011", "011111011",
                            "011111110", "011111110", "011111110", "011111110", "011111111", "011111111", "011111111", "011111111",
                            "110111000", "110110010", "100111010", "110011010", "110111001", "110110011", "100111011", "110011011",
                            "110111010", "110110110", "100111110", "110011110", "110111011", "110110111", "100111111", "110011111",
                            "110111100", "110111010", "101111010", "110111010", "110111101", "110111011", "101111011", "110111011",
                            "110111110", "110111110", "101111110", "110111110", "110111111", "110111111", "101111111", "110111111",
                            "111111000", "111110010", "110111010", "111011010", "111111001", "111110011", "110111011", "111011011",
                            "111111010", "111110110", "110111110", "111011110", "111111011", "111110111", "110111111", "111011111",
                            "111111100", "111111010", "111111010", "111111010", "111111101", "111111011", "111111011", "111111011",
                            "111111110", "111111110", "111111110", "111111110", "111111111", "111111111", "111111111", "111111111",
                            "101010001", "101010100", "100010101", "001010101", "101010010", "100011100", "010010101", "001110001",
                            "101010011", "101011100", "110010101", "001110101", "101010100", "100010101", "001010101", "101010001",
                            "101010101", "101010101", "101010101", "101010101", "101010110", "100011101", "011010101", "101110001",
                            "101010111", "101011101", "111010101", "101110101", "101011001", "101010110", "100010111", "001010111",
                            "101011010", "100011110", "010010111", "001110011", "101011011", "101011110", "110010111", "001110111",
                            "101011100", "100010111", "001010111", "101010011", "101011101", "101010111", "101010111", "101010111",
                            "101011110", "100011111", "011010111", "101110011", "101011111", "101011111", "111010111", "101110111",
                            "101110001", "101110100", "100011101", "001011101", "101110010", "100111100", "010011101", "001111001",
                            "101110011", "101111100", "110011101", "001111101", "101110100", "100110101", "001011101", "101011001",
                            "101110101", "101110101", "101011101", "101011101", "101110110", "100111101", "011011101", "101111001",
                            "101110111", "101111101", "111011101", "101111101", "101111001", "101110110", "100011111", "001011111",
                            "101111010", "100111110", "010011111", "001111011", "101111011", "101111110", "110011111", "001111111",
                            "101111100", "100110111", "001011111", "101011011", "101111101", "101110111", "101011111", "101011111",
                            "101111110", "100111111", "011011111", "101111011", "101111111", "101111111", "111011111", "101111111",
                            "111010001", "111010100", "100110101", "011010101", "111010010", "110011100", "010110101", "011110001",
                            "111010011", "111011100", "110110101", "011110101", "111010100", "110010101", "001110101", "111010001",
                            "111010101", "111010101", "101110101", "111010101", "111010110", "110011101", "011110101", "111110001",
                            "111010111", "111011101", "111110101", "111110101", "111011001", "111010110", "100110111", "011010111",
                            "111011010", "110011110", "010110111", "011110011", "111011011", "111011110", "110110111", "011110111",
                            "111011100", "110010111", "001110111", "111010011", "111011101", "111010111", "101110111", "111010111",
                            "111011110", "110011111", "011110111", "111110011", "111011111", "111011111", "111110111", "111110111",
                            "111110001", "111110100", "100111101", "011011101", "111110010", "110111100", "010111101", "011111001",
                            "111110011", "111111100", "110111101", "011111101", "111110100", "110110101", "001111101", "111011001",
                            "111110101", "111110101", "101111101", "111011101", "111110110", "110111101", "011111101", "111111001",
                            "111110111", "111111101", "111111101", "111111101", "111111001", "111110110", "100111111", "011011111",
                            "111111010", "110111110", "010111111", "011111011", "111111011", "111111110", "110111111", "011111111",
                            "111111100", "110110111", "001111111", "111011011", "111111101", "111110111", "101111111", "111011111",
                            "111111110", "110111111", "011111111", "111111011", "111111111", "111111111", "111111111", "111111111",
                            "010011100", "010110001", "001110010", "100011010", "010011101", "010110101", "001110011", "100011110",
                            "110011100", "011110001", "101110010", "101011010", "110011101", "011110101", "101110011", "101011110"};

    // convert original image to binary image
    for (i = 1; i < Size - 1; i++) {
        for (j = 1; j < Size - 1; j++) {
            if(Imagedata[i-1][j-1][0] == 255) { img_extd[i][j][0]=1; }
            else { img_extd[i][j][0]=0; }
        }
    }

    // ... Skeletonizing ...
    for(iter=0;iter<200;iter++)
    {
        // compute pixel stream map
        for (i = 1; i < Size - 1; i++) {
            for (j = 1; j < Size - 1; j++) {
                if (img_extd[i][j][0] == 1)
                {
                    bond_number=2*(img_extd[i-1][j][0]+img_extd[i][j+1][0]+img_extd[i][j-1][0]+img_extd[i+1][j][0])+(img_extd[i-1][j-1][0]+img_extd[i-1][j+1][0]+img_extd[i+1][j-1][0]+img_extd[i + 1][j + 1][0]);
                    pixel_stream[i-1][j-1] = to_string(img_extd[i-1][j-1][0]) + to_string(img_extd[i-1][j][0]) + to_string(img_extd[i-1][j+1][0])
                                             + to_string(img_extd[i][j - 1][0]) + to_string(img_extd[i][j][0]) + to_string(img_extd[i][j+1][0])
                                             + to_string(img_extd[i+1][j-1][0]) + to_string(img_extd[i+1][j][0]) + to_string(img_extd[i+1][j+1][0]);
                    bond_map[i - 1][j - 1] = bond_number;
                }
                else { bond_map[i - 1][j - 1] = 0; }
            }
        }

        // compute mark stream
        for (i = 0; i < size; i++) {
            for (j = 0; j < size; j++) {
                if (bond_map[i][j] != 0) {
                    M[i][j] = HitOrMiss(pixel_stream[i][j], con_mask, 40);
                }
                else { M[i][j] = 0; }
            }
        }

        // put extended mark map to true size mark map
        for (i = 1; i < Size - 1; i++) {
            for (j = 1; j < Size - 1; j++) {
                m[i][j] = M[i - 1][j - 1];
            }
        }

        // compute P map
        for (i = 1; i < Size - 1; i++) {
            for (j = 1; j < Size - 1; j++) {
                mark_stream = to_string(m[i-1][j-1]) + to_string(m[i-1][j]) + to_string(m[i-1][j+1])
                              + to_string(m[i][j - 1]) + to_string(m[i][j]) + to_string(m[i][j + 1])
                              + to_string(m[i+1][j-1]) + to_string(m[i+1][j]) + to_string(m[i+1][j+1]);
                if (m[i][j] == 1) { P[i - 1][j - 1] = HitOrMiss(mark_stream, uncon_mask, 332); }
            }
        }

        // output
        for(i=1;i<size-1;i++) {
            for(j=1;j<size-1;j++) {
                output[i][j][0] = (unsigned char) output_logic(img_extd[i+1][j+1][0], M[i][j], P[i][j]);
                if(output[i][j][0] == 255) {img_extd[i+1][j+1][0] = 1;}
                else { img_extd[i+1][j+1][0] = 0;}
            }
        }

        // return to top, loop again
    }

    // bridging
    for(i=0;i<size;i++){
        for(j=0;j<size;j++){
            if(output[i][j][0] == 255) {output[i][j][0] = 1;}
            else { output[i][j][0] = 0;}
        }
    }
    for(i=1;i<size-1;i++){
        for(j=1;j<size-1;j++){
            output[i][j][0]=(unsigned char)bridging(output[i][j][0],output[i][j+1][0],output[i-1][j+1][0],output[i-1][j][0],output[i-1][j-1][0],output[i][j-1][0],output[i+1][j-1][0],output[i+1][j][0],output[i+1][j+1][0]);
        }
    }
    for(i=0;i<size;i++){
        for(j=0;j<size;j++){
            if(output[i][j][0] == 1) {output[i][j][0] = 255;}
            else { output[i][j][0] = 0;}
        }
    }


    // Write image data (filename specified by second argument) from image data matrix
    if (!(file=fopen("/Users/wenjun/ee569/hw3/pattern4_skeletonizing.raw","wb"))) {
        cout << "Cannot open file: " << endl;
        exit(1);
    }
    fwrite(output, sizeof(unsigned char), 375*375*1, file);
    fclose(file);
    return 0;
}

