//
//  b_pro1.cpp
//  
//
//  Created by shengchang gao on 2/18/19.
//
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <string>
#include <vector>
#include <fstream>
using namespace std;
int Find_pattern(string ps,string bound[],int size);

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    FILE *file;
    int BytesPerPixel;
    int SizeCo;
    int SizeRo;
    int Size = 256;
    
    // Check for proper syntax
    if (argc < 3) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
        return 0;
    }
    
    // Check if image is grayscale or color
    if (argc < 4) {
        BytesPerPixel = 1; // default is grey image
    } else {
        BytesPerPixel = atoi(argv[3]);
        // Check if size is specified
        if (argc >= 5) {
            SizeCo = atoi(argv[4]);
            SizeRo = atoi(argv[5]);
        }
    }
    
    // Allocate image data array
    unsigned char Imagedata[SizeRo][SizeCo][BytesPerPixel];
    // Read image (filename specified by first argument) into image data matrix
    if (!(file=fopen(argv[1],"rb"))) {
        cout << "Cannot open file: " << argv[1] <<endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), SizeRo*SizeCo*BytesPerPixel, file);
    fclose(file);

    //////////////     code from here    ///////////////////////
    int c;                  //loop counting
    int SizeC = SizeCo + 2;
    int SizeR = SizeRo + 2;
    int Imagenew[SizeR][SizeC][BytesPerPixel];
    int bound_t;
    int bound[SizeRo][SizeCo];
    std::string ps[SizeRo][SizeCo];
    int i, j = 0;
    int M[SizeRo][SizeCo];
    ////////////////////////  conditional mask //////////////////////////

    std::string bound1[4] = {"001010000", "100010000", "000010100", "000010001"};
    std::string bound2[4] = {"000011000", "010010000", "000110000", "000010010"};
    std::string bound3[8] = {"001011000", "011010000", "110010000", "100110000", "000110100", "000010110",
                             "000010011", "000011001"};
    std::string bound4[4] = {"001011001", "111010000", "100110100", "000010111"};
    std::string bound5[8] = {"110011000", "010011001", "011110000", "001011010", "011011000", "110110000",
                             "000110110", "000011011"};
    std::string bound6[10] = {"110011001", "011110100", "111011000", "011011001", "111110000", "110110100",
                              "100110110", "000110111", "000011111", "001011011"};
    std::string bound7[4] = {"111011001", "111110100", "100110111", "001011111"};
    std::string bound8[4] = {"011011011", "111111000", "110110110", "000111111"};
    std::string bound9[8] = {"111011011", "011011111", "111111100", "111111001", "111110110", "110110111",
                             "100111111", "001111111"};
    std::string bound10[4] = {"111011111", "111111101", "111110111", "101111111"};

    ///////////////////////   unconditional mask  bank ////////////////////

    std::string ucb[332] = {"001010000", "100010000", "000010010", "000011000", "001011000", "011010000",
                            "110010000", "100110000", "000110100",
                            "000010110", "000010011", "000011001", "011110000", "110011000", "010011001",
                            "001011010", "011010100", "011011100",
                            "001011100", "110110001", "110010001", "100110001", "001110110", "001110100",
                            "001010110", "100011011", "100011001",
                            "100001011", "110110000", "110110001", "110110010", "110110011", "110110100",
                            "110110101", "110110110", "110110111",
                            "110111000", "110111001", "110111010", "110111011", "110111100", "110111101",
                            "110111110", "110111111",
                            "111110000", "111110001", "111110010", "111110011", "111110100", "111110101",
                            "111110110", "111110111",
                            "111111000", "111111001", "111111010", "111111011", "111111100", "111111101",
                            "111111110", "111111111",
                            "010111000", "010111000", "000111010", "000111010", "010110010", "010110010",
                            "010011010", "010011010",
                            "010111100", "010111001", "000111011", "000111110", "011110010", "010110011",
                            "010011011", "011011010",
                            "110111000", "011111000", "001111010", "100111010", "110110010", "010110110",
                            "010011110", "110011010",
                            "110111100", "011111001", "001111011", "100111110", "111110010", "010110111",
                            "010011111", "111011010",
                            "101010001", "101010100", "100010101", "001010101", "101010010", "100011100",
                            "010010101", "001110001",
                            "101010011", "101011100", "110010101", "001110101", "101010100", "100010101",
                            "001010101", "101010001",
                            "101010101", "101010101", "101010101", "101010101", "101010110", "100011101",
                            "011010101", "101110001",
                            "101010111", "101011101", "111010101", "101110101", "101011001", "101010110",
                            "100010111", "001010111",
                            "101011010", "100011110", "010010111", "001110011", "101011011", "101011110",
                            "110010111", "001110111",
                            "101011100", "100010111", "001010111", "101010011", "101011101", "101010111",
                            "101010111", "101010111",
                            "101011110", "100011111", "011010111", "101110011", "101011111", "101011111",
                            "111010111", "101110111",

                            "101110001", "101110100", "100011101", "001011101", "101110010", "100111100",
                            "010011101", "001111001",
                            "101110011", "101111100", "110011101", "001111101", "101110100", "100110101",
                            "001011101", "101011001",
                            "101110101", "101110101", "101011101", "101011101", "101110110", "100111101",
                            "011011101", "101111001",
                            "101110111", "101111101", "111011101", "101111101", "101111001", "101110110",
                            "100011111", "001011111",
                            "101111010", "100111110", "010011111", "001111011", "101111011", "101111110",
                            "110011111", "001111111",
                            "101111100", "100110111", "001011111", "101011011", "101111101", "101110111",
                            "101011111", "101011111",
                            "101111110", "100111111", "011011111", "101111011", "101111111", "101111111",
                            "111011111", "101111111",

                            "111010001", "111010100", "100110101", "011010101", "111010010", "110011100",
                            "010110101", "011110001",
                            "111010011", "111011100", "110110101", "011110101", "111010100", "110010101",
                            "001110101", "111010001",
                            "111010101", "111010101", "101110101", "111010101", "111010110", "110011101",
                            "011110101", "111110001",
                            "111010111", "111011101", "111110101", "111110101", "111011001", "111010110",
                            "100110111", "011010111",
                            "111011010", "110011110", "010110111", "011110011", "111011011", "111011110",
                            "110110111", "011110111",
                            "111011100", "110010111", "001110111", "111010011", "111011101", "111010111",
                            "101110111", "111010111",
                            "111011110", "110011111", "011110111", "111110011", "111011111", "111011111",
                            "111110111", "111110111",

                            "111110001", "111110100", "100111101", "011011101", "111110010", "110111100",
                            "010111101", "011111001",
                            "111110011", "111111100", "110111101", "011111101", "111110100", "110110101",
                            "001111101", "111011001",
                            "111110101", "111110101", "101111101", "111011101", "111110110", "110111101",
                            "011111101", "111111001",
                            "111110111", "111111101", "111111101", "111111101", "111111001", "111110110",
                            "100111111", "011011111",
                            "111111010", "110111110", "010111111", "011111011", "111111011", "111111110",
                            "110111111", "011111111",
                            "111111100", "110110111", "001111111", "111011011", "111111101", "111110111",
                            "101111111", "111011111",
                            "111111110", "110111111", "011111111", "111111011", "111111111", "111111111",
                            "111111111", "111111111",
                            "010011100", "010110001", "001110010", "100011010", "010011101", "010110101",
                            "001110011", "100011110",
                            "110011100", "011110001", "101110010", "101011010", "110011101", "011110101",
                            "101110011", "101011110"};
    /////////////////////////////////////////////////////////////////////////////////////////////////////////
    int M_n[SizeR][SizeC];
    int P[SizeRo][SizeCo];                          //array value of P
    string ms;     //declare the string of M
    unsigned char output[SizeRo][SizeCo][1];
    for (i = 1; i < SizeR - 1; i++) {
        for (j = 1; j < SizeC - 1; j++) {
            Imagenew[i][j][0] = int(Imagedata[i - 1][j - 1][0]) / 255;
        }
    }
    //////////////////////////////////// calucation begin ///////////////////////////////////////////////////
    //do the image extension
    for(c=0;c < 200;c++) {

        /*int SizeC = SizeCo + 2;
        int SizeR = SizeRo + 2;
        int Imagenew[SizeR][SizeC][BytesPerPixel];
        int i, j = 0;
         */

        //assign the background and copy the input information
        for (j = 1; j < SizeC - 1; j++) {
            Imagenew[0][j][0] = 0;
            Imagenew[SizeR - 1][j][0] = 0;
        }
        for (i = 1; i < SizeR - 1; i++) {
            Imagenew[i][0][0] = 0;
            Imagenew[i][SizeC - 1][0] = 0;
        }
        Imagenew[0][0][0] = 0;
        Imagenew[0][SizeC - 1][0] = 0;
        Imagenew[SizeR - 1][0][0] = 0;
        Imagenew[SizeR - 1][SizeC - 1][0] = 0;
        //ofstream myfile;
        //myfile.open("test.txt");
        /*for (i = 1; i < SizeR - 1; i++) {
            for (j = 1; j < SizeC - 1; j++) {
                Imagenew[i][j][0] = int(Imagedata[i - 1][j - 1][0]) / 255;
            }
        }
         */
        //////////////////////////////// stage 1 //////////////////////////////////////////////
        //calculate the bound value and record bound value into bound array
        /*int bound_t;
        int bound[SizeRo][SizeCo];
        std::string ps[SizeRo][SizeCo];
         */
        for (i = 1; i < SizeR - 1; i++) {
            for (j = 1; j < SizeC - 1; j++) {
                if (Imagenew[i][j][0] == 1) {
                    bound_t = 2 * (Imagenew[i - 1][j][0] + Imagenew[i][j + 1][0] + Imagenew[i][j - 1][0] +
                                   Imagenew[i + 1][j][0]) +
                              (Imagenew[i - 1][j - 1][0] + Imagenew[i - 1][j + 1][0] + Imagenew[i + 1][j - 1][0] +
                               Imagenew[i + 1][j + 1][0]);
                    bound[i - 1][j - 1] = bound_t;
                    //creat the string for the pixel
                    ps[i - 1][j - 1] = to_string(Imagenew[i - 1][j - 1][0]) + to_string(Imagenew[i - 1][j][0]) +
                                       to_string(Imagenew[i - 1][j + 1][0])
                                       + to_string(Imagenew[i][j - 1][0]) + to_string(Imagenew[i][j][0]) +
                                       to_string(Imagenew[i][j + 1][0])
                                       + to_string(Imagenew[i + 1][j - 1][0]) + to_string(Imagenew[i + 1][j][0]) +
                                       to_string(Imagenew[i + 1][j + 1][0]);
                } else {
                    bound[i - 1][j - 1] = 0;
                }
            }
        }
        //myfile.close();
        //try to find the value of M using the condition table
        //also recording the M value for each pixel
        /*int M[SizeRo][SizeCo];
        std::string bound1[4] = {"001010000", "100010000", "000010100", "000010001"};
        std::string bound2[4] = {"000011000", "010010000", "000110000", "000010010"};
        std::string bound3[8] = {"001011000", "011010000", "110010000", "100110000", "000110100", "000010110",
                                 "000010011", "000011001"};
        std::string bound4[4] = {"001011001", "111010000", "100110100", "000010111"};
        std::string bound5[8] = {"110011000", "010011001", "011110000", "001011010", "011011000", "110110000",
                                 "000110110", "000011011"};
        std::string bound6[10] = {"110011001", "011110100", "111011000", "011011001", "111110000", "110110100",
                                  "100110110", "000110111", "000011111", "001011011"};
        std::string bound7[4] = {"111011001", "111110100", "100110111", "001011111"};
        std::string bound8[4] = {"011011011", "111111000", "110110110", "000111111"};
        std::string bound9[8] = {"111011011", "011011111", "111111100", "111111001", "111110110", "110110111",
                                 "100111111", "001111111"};
        std::string bound10[4] = {"111011111", "111111101", "111110111", "101111111"};

        for (i = 0; i < SizeRo; i++) {
            for (j = 0; j < SizeCo; j++) {
                if (bound[i][j] != 0) {
                    if (bound[i][j] == 1) {
                        M[i][j] = Find_pattern(ps[i][j], bound1);
                    } else if (bound[i][j] == 2) {
                        M[i][j] = Find_pattern(ps[i][j], bound2);
                    } else if (bound[i][j] == 3) {
                        M[i][j] = Find_pattern(ps[i][j], bound3);
                    } else if (bound[i][j] == 4) {
                        M[i][j] = Find_pattern(ps[i][j], bound4);
                    } else if (bound[i][j] == 5) {
                        M[i][j] = Find_pattern(ps[i][j], bound5);
                    } else if (bound[i][j] == 6) {
                        M[i][j] = Find_pattern(ps[i][j], bound6);
                    } else if (bound[i][j] == 7) {
                        M[i][j] = Find_pattern(ps[i][j], bound7);
                    } else if (bound[i][j] == 8) {
                        M[i][j] = Find_pattern(ps[i][j], bound8);
                    } else if (bound[i][j] == 9) {
                        M[i][j] = Find_pattern(ps[i][j], bound9);
                    } else if (bound[i][j] == 10) {
                        M[i][j] = Find_pattern(ps[i][j], bound10);
                    }

                } else {
                    M[i][j] = 0;
                }
            }
        }
         */
        for (i = 0; i < SizeRo; i++) {
            for (j = 0; j < SizeCo; j++) {
                if (bound[i][j] != 0) {
                    if (bound[i][j] == 1) {
                        M[i][j] = Find_pattern(ps[i][j], bound1,sizeof(bound1)/sizeof(bound1[0]));
                        ps[i][j].clear();
                    } else if (bound[i][j] == 2) {
                        M[i][j] = Find_pattern(ps[i][j], bound2,sizeof(bound2)/sizeof(bound2[0]));
                        ps[i][j].clear();
                    } else if (bound[i][j] == 3) {
                        M[i][j] = Find_pattern(ps[i][j], bound3,sizeof(bound3)/sizeof(bound3[0]));
                        ps[i][j].clear();
                    } else if (bound[i][j] == 4) {
                        M[i][j] = Find_pattern(ps[i][j], bound4,sizeof(bound4)/sizeof(bound4[0]));
                        ps[i][j].clear();
                    } else if (bound[i][j] == 5) {
                        M[i][j] = Find_pattern(ps[i][j], bound5,sizeof(bound5)/sizeof(bound5[0]));
                        ps[i][j].clear();
                    } else if (bound[i][j] == 6) {
                        M[i][j] = Find_pattern(ps[i][j], bound6,sizeof(bound6)/sizeof(bound6[0]));
                        ps[i][j].clear();
                    } else if (bound[i][j] == 7) {
                        M[i][j] = Find_pattern(ps[i][j], bound7,sizeof(bound7)/sizeof(bound7[0]));
                        ps[i][j].clear();
                    } else if (bound[i][j] == 8) {
                        M[i][j] = Find_pattern(ps[i][j], bound8,sizeof(bound8)/sizeof(bound8[0]));
                        ps[i][j].clear();
                    } else if (bound[i][j] == 9) {
                        M[i][j] = Find_pattern(ps[i][j], bound9,sizeof(bound9)/sizeof(bound9[0]));
                        ps[i][j].clear();
                    } else if (bound[i][j] == 10) {
                        M[i][j] = Find_pattern(ps[i][j], bound10,sizeof(bound10)/sizeof(bound10[0]));
                        ps[i][j].clear();
                    }

                } else {
                    M[i][j] = 0;
                    ps[i][j].clear();
                }
            }
        }
        ////////////////////////////       stage 2      /////////////////////////////////////////////////
        //unconditional table
        /*int P[SizeRo][SizeCo];                          //array value of P
        std::string p1[2] = {"001010000","100010000"};
        std::string p2[2] = {"000010010","000011000"};
        std::string p3[8] = {"001011000","011010000","110010000","100110000","000110100",
                             "000010110","000010011","000011001"};
        std::string p4[4] = {"011110000","110011000","010011001","001011010"};
        std::string p5[12]= {"011010100","011011100","001011100",
                             "110110001","110010001","100110001",
                             "001110110","001110100","001010110",
                             "100011011","100011001","100001011"};
        std::string p6[32] = {"110110000","110110001","110110010","110110011","110110100","110110101","110110110","110110111",
                              "110111000","110111001","110111010","110111011","110111100","110111101","110111110","110111111",
                              "111110000","111110001","111110010","111110011","111110100","111110101","111110110","111110111",
                              "111111000","111111001","111111010","111111011","111111100","111111101","111111110","111111111"};

        std::string p7[32] ={"010111000","010111000","000111010","000111010","010110010","010110010","010011010","010011010",
                             "010111100","010111001","000111011","000111110","011110010","010110011","010011011","011011010",
                             "110111000","011111000","001111010","100111010","110110010","010110110","010011110","110011010",
                             "110111100","011111001","001111011","100111110","111110010","010110111","010011111","111011010"};

        std::string p8[224] ={"101010001","101010100","100010101","001010101","101010010","100011100","010010101","001110001",
                              "101010011","101011100","110010101","001110101","101010100","100010101","001010101","101010001",
                              "101010101","101010101","101010101","101010101","101010110","100011101","011010101","101110001",
                              "101010111","101011101","111010101","101110101","101011001","101010110","100010111","001010111",
                              "101011010","100011110","010010111","001110011","101011011","101011110","110010111","001110111",
                              "101011100","100010111","001010111","101010011","101011101","101010111","101010111","101010111",
                              "101011110","100011111","011010111","101110011","101011111","101011111","111010111","101110111",

                              "101110001","101110100","100011101","001011101","101110010","100111100","010011101","001111001",
                              "101110011","101111100","110011101","001111101","101110100","100110101","001011101","101011001",
                              "101110101","101110101","101011101","101011101","101110110","100111101","011011101","101111001",
                              "101110111","101111101","111011101","101111101","101111001","101110110","100011111","001011111",
                              "101111010","100111110","010011111","001111011","101111011","101111110","110011111","001111111",
                              "101111100","100110111","001011111","101011011","101111101","101110111","101011111","101011111",
                              "101111110","100111111","011011111","101111011","101111111","101111111","111011111","101111111",

                              "111010001","111010100","100110101","011010101","111010010","110011100","010110101","011110001",
                              "111010011","111011100","110110101","011110101","111010100","110010101","001110101","111010001",
                              "111010101","111010101","101110101","111010101","111010110","110011101","011110101","111110001",
                              "111010111","111011101","111110101","111110101","111011001","111010110","100110111","011010111",
                              "111011010","110011110","010110111","011110011","111011011","111011110","110110111","011110111",
                              "111011100","110010111","001110111","111010011","111011101","111010111","101110111","111010111",
                              "111011110","110011111","011110111","111110011","111011111","111011111","111110111","111110111",

                              "111110001","111110100","100111101","011011101","111110010","110111100","010111101","011111001",
                              "111110011","111111100","110111101","011111101","111110100","110110101","001111101","111011001",
                              "111110101","111110101","101111101","111011101","111110110","110111101","011111101","111111001",
                              "111110111","111111101","111111101","111111101","111111001","111110110","100111111","011011111",
                              "111111010","110111110","010111111","011111011","111111011","111111110","110111111","011111111",
                              "111111100","110110111","001111111","111011011","111111101","111110111","101111111","111011111",
                              "111111110","110111111","011111111","111111011","111111111","111111111","111111111","111111111"};

        std::string p9[16] = {"010011100","010110001","001110010","100011010","010011101","010110101","001110011","100011110",
                              "110011100","011110001","101110010","101011010","110011101","011110101","101110011","101011110"};
    */
        /*///////////   unconditional bank/////////////////////
        std::string ucb[332] = {"001010000", "100010000", "000010010", "000011000", "001011000", "011010000",
                                "110010000", "100110000", "000110100",
                                "000010110", "000010011", "000011001", "011110000", "110011000", "010011001",
                                "001011010", "011010100", "011011100",
                                "001011100", "110110001", "110010001", "100110001", "001110110", "001110100",
                                "001010110", "100011011", "100011001",
                                "100001011", "110110000", "110110001", "110110010", "110110011", "110110100",
                                "110110101", "110110110", "110110111",
                                "110111000", "110111001", "110111010", "110111011", "110111100", "110111101",
                                "110111110", "110111111",
                                "111110000", "111110001", "111110010", "111110011", "111110100", "111110101",
                                "111110110", "111110111",
                                "111111000", "111111001", "111111010", "111111011", "111111100", "111111101",
                                "111111110", "111111111",
                                "010111000", "010111000", "000111010", "000111010", "010110010", "010110010",
                                "010011010", "010011010",
                                "010111100", "010111001", "000111011", "000111110", "011110010", "010110011",
                                "010011011", "011011010",
                                "110111000", "011111000", "001111010", "100111010", "110110010", "010110110",
                                "010011110", "110011010",
                                "110111100", "011111001", "001111011", "100111110", "111110010", "010110111",
                                "010011111", "111011010",
                                "101010001", "101010100", "100010101", "001010101", "101010010", "100011100",
                                "010010101", "001110001",
                                "101010011", "101011100", "110010101", "001110101", "101010100", "100010101",
                                "001010101", "101010001",
                                "101010101", "101010101", "101010101", "101010101", "101010110", "100011101",
                                "011010101", "101110001",
                                "101010111", "101011101", "111010101", "101110101", "101011001", "101010110",
                                "100010111", "001010111",
                                "101011010", "100011110", "010010111", "001110011", "101011011", "101011110",
                                "110010111", "001110111",
                                "101011100", "100010111", "001010111", "101010011", "101011101", "101010111",
                                "101010111", "101010111",
                                "101011110", "100011111", "011010111", "101110011", "101011111", "101011111",
                                "111010111", "101110111",

                                "101110001", "101110100", "100011101", "001011101", "101110010", "100111100",
                                "010011101", "001111001",
                                "101110011", "101111100", "110011101", "001111101", "101110100", "100110101",
                                "001011101", "101011001",
                                "101110101", "101110101", "101011101", "101011101", "101110110", "100111101",
                                "011011101", "101111001",
                                "101110111", "101111101", "111011101", "101111101", "101111001", "101110110",
                                "100011111", "001011111",
                                "101111010", "100111110", "010011111", "001111011", "101111011", "101111110",
                                "110011111", "001111111",
                                "101111100", "100110111", "001011111", "101011011", "101111101", "101110111",
                                "101011111", "101011111",
                                "101111110", "100111111", "011011111", "101111011", "101111111", "101111111",
                                "111011111", "101111111",

                                "111010001", "111010100", "100110101", "011010101", "111010010", "110011100",
                                "010110101", "011110001",
                                "111010011", "111011100", "110110101", "011110101", "111010100", "110010101",
                                "001110101", "111010001",
                                "111010101", "111010101", "101110101", "111010101", "111010110", "110011101",
                                "011110101", "111110001",
                                "111010111", "111011101", "111110101", "111110101", "111011001", "111010110",
                                "100110111", "011010111",
                                "111011010", "110011110", "010110111", "011110011", "111011011", "111011110",
                                "110110111", "011110111",
                                "111011100", "110010111", "001110111", "111010011", "111011101", "111010111",
                                "101110111", "111010111",
                                "111011110", "110011111", "011110111", "111110011", "111011111", "111011111",
                                "111110111", "111110111",

                                "111110001", "111110100", "100111101", "011011101", "111110010", "110111100",
                                "010111101", "011111001",
                                "111110011", "111111100", "110111101", "011111101", "111110100", "110110101",
                                "001111101", "111011001",
                                "111110101", "111110101", "101111101", "111011101", "111110110", "110111101",
                                "011111101", "111111001",
                                "111110111", "111111101", "111111101", "111111101", "111111001", "111110110",
                                "100111111", "011011111",
                                "111111010", "110111110", "010111111", "011111011", "111111011", "111111110",
                                "110111111", "011111111",
                                "111111100", "110110111", "001111111", "111011011", "111111101", "111110111",
                                "101111111", "111011111",
                                "111111110", "110111111", "011111111", "111111011", "111111111", "111111111",
                                "111111111", "111111111",
                                "010011100", "010110001", "001110010", "100011010", "010011101", "010110101",
                                "001110011", "100011110",
                                "110011100", "011110001", "101110010", "101011010", "110011101", "011110101",
                                "101110011", "101011110"};
        /////////////////////   extension of M ////////////////////
        int M_n[SizeR][SizeC];
        int P[SizeRo][SizeCo];                          //array value of P*/
        //assign the background and copy the input information
        for (j = 1; j < SizeC - 1; j++) {
            M_n[0][j] = 0;
            M_n[SizeR - 1][j] = 0;
        }
        for (i = 1; i < SizeR - 1; i++) {
            M_n[i][0] = 0;
            M_n[i][SizeC - 1] = 0;
        }
        M_n[0][0] = 0;
        M_n[0][SizeC - 1] = 0;
        M_n[SizeR - 1][0] = 0;
        M_n[SizeR - 1][SizeC - 1] = 0;

        for (i = 1; i < SizeR - 1; i++) {
            for (j = 1; j < SizeC - 1; j++) {
                M_n[i][j] = M[i - 1][j - 1];
            }
        }
        //creat the string array MS
        //string ms;     //declare the string of M

        for (i = 1; i < SizeR - 1; i++) {
            for (j = 1; j < SizeC - 1; j++) {

                ms = to_string(M_n[i - 1][j - 1]) + to_string(M_n[i - 1][j]) + to_string(M_n[i - 1][j + 1]) +
                     to_string(M_n[i][j - 1]) + to_string(M_n[i][j]) + to_string(M_n[i][j + 1]) +
                     to_string(M_n[i + 1][j - 1]) + to_string(M_n[i + 1][j]) + to_string(M_n[i + 1][j + 1]);

                if (M_n[i][j] != 0) {
                    P[i - 1][j - 1] = Find_pattern(ms, ucb,sizeof(ucb)/sizeof(ucb[0]));
                }
                ms.clear();
            }
        }

        // for final G information
        //unsigned char output[SizeRo][SizeCo][1];
        for (i = 0; i < SizeRo; i++) {
            for (j = 0; j < SizeCo; j++) {
                output[i][j][0] = 255 * (((Imagenew[i+1][j+1][0]) == 1) && ((!M[i][j]) || (P[i][j])));
            }
        }
        //assign new array value
        for (i = 0; i < SizeRo; i++) {
            for (j = 0; j < SizeCo; j++) {
                Imagenew[i+1][j+1][0] = output[i][j][0]/255;
            }
        }

    }

    // Write image data (filename specified by second argument) from image data matrix
    if (!(file=fopen(argv[2],"wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }

    fwrite(output,sizeof(unsigned char), (SizeCo)*(SizeRo)*BytesPerPixel, file);
    fclose(file);
    
    return 0;
}

int Find_pattern(string ps,string bound[],int size){
    //int size = sizeof(bound)/sizeof(bound[0]);
    //cout<<size<<endl;
    for(int k = 0;k < size; k++){
        if(ps.compare(bound[k]) == 0){
            return 1;       //hit masks
        }
    }
    return 0;               //not hit masks
}

